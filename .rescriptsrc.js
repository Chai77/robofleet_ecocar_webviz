const path = require('path');
const { edit, getPaths } = require('@rescripts/utilities');

// test a Webpack "test" rule against a string
const doTest = (test, matchStr) => {
    if (Symbol.iterator in test) {
        return Array.from(test).some(x => x.test(matchStr));
    } else if (test instanceof RegExp) {
        return test.test(matchStr);
    }
    throw new Error("Provided test was not an array or RegExp");
}

// determine if an object is a webpack rule that loads TypeScript
const isTsRule = obj => obj && obj.test && obj.loader && doTest(obj.test, "file.ts");

module.exports = [
    // disable warnings for code generated by Flatbuffers compiler
    ["use-eslint-config", {
        "extends": ["react-app"],
        "overrides": [
            {
                "files": ["**/*_generated.ts"],
                "rules": {
                    "no-redeclare": 0,
                    "@typescript-eslint/no-unused-vars": 0
                }
            }
        ]
    }],
    (config) => {
        // don't load generated schema with babel-loader
        config = edit(
            (rule) => {
                if (!rule.hasOwnProperty("exclude"))
                    rule.exclude = [];
                rule.exclude.push(path.resolve(__dirname, "src/schema_generated.ts"));
                return rule;
            },
            getPaths(isTsRule, config),
            config,
        );
        
        // load generated schema with ts-loader
        config = edit(
            (module) => {
                module.rules.unshift({
                    include: [path.resolve(__dirname, "src/schema_generated.ts")],
                    loader: require.resolve("ts-loader"),
                    options: {
                        configFile: "tsconfig.tsc.json"
                    }
                });
                return module;
            },
            getPaths(x => x.rules, config),
            config
        );

        return config;
    }
];
